## 1. [643. Максимальный средний подмассив I](https://leetcode.com/problems/maximum-average-subarray-i/)

### Условие задачи

Дан массив целых чисел `nums` и целое число `k`, найдите максимальное среднее значение подмассива длиной `k`.

**Примеры:**

```
Пример 1:
Вход: nums = [1,12,-5,-6,50,3], k = 4
Выход: 12.75
Объяснение: Подмассив [12,-5,-6,50] имеет среднее (12 + (-5) + (-6) + 50) / 4 = 51 / 4 = 12.75.

Пример 2:
Вход: nums = [5], k = 1
Выход: 5.0
```

**Ограничения:**
- `1 <= k <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`

### Решения

#### 1. Полный перебор (Brute Force Approach)

**Идея:** Вычисляем сумму каждого подмассива длиной `k` и находим максимальное среднее значение.

**Интуиция:** Простой подход, но неэффективный из-за повторных вычислений сумм.

```python
def findMaxAverage(nums, k):
    n = len(nums)
    max_avg = float('-inf')
    
    for i in range(n - k + 1):
        current_sum = 0
        for j in range(i, i + k):
            current_sum += nums[j]
        current_avg = current_sum / k
        max_avg = max(max_avg, current_avg)
    
    return max_avg
```

**Временная сложность:** O(n * k)  
- n — длина массива, для каждого начального индекса суммируем k элементов.

**Пространственная сложность:** O(1)  
- Используется фиксированное количество дополнительной памяти.

#### 2. Скользящее окно (Sliding Window Approach)

**Идея:** Используем скользящее окно фиксированного размера `k`, чтобы избежать повторных вычислений сумм.

**Интуиция:** При движении окна добавляем новый элемент и вычитаем старый, обновляя сумму за O(1).

```python
def findMaxAverage(nums, k):
    n = len(nums)
    current_sum = sum(nums[:k])
    max_sum = current_sum

    for i in range(k, n):
        current_sum += nums[i] - nums[i - k]
        max_sum = max(max_sum, current_sum)
    
    return max_sum / k
```

**Временная сложность:** O(n)  
- Один проход по массиву, начальная сумма вычисляется за O(k).

**Пространственная сложность:** O(1)  
- Используется только несколько переменных.

---
## 2. [438. Найти все анаграммы в строке](https://leetcode.com/problems/find-all-anagrams-in-a-string/)

### Условие задачи

Даны две строки `s` и `p`, найдите все начальные индексы подстрок в `s`, которые являются анаграммами строки `p`. Анаграмма — это строка, содержащая те же символы с той же частотой, но в любом порядке.

**Примеры:**

```
Пример 1:
Вход: s = "cbaebabacd", p = "abc"
Выход: [0,6]
Объяснение: Подстроки, начинающиеся с индексов 0 ("cba") и 6 ("bac"), являются анаграммами "abc".

Пример 2:
Вход: s = "abab", p = "ab"
Выход: [0,1,2]
```

**Ограничения:**
- `1 <= s.length, p.length <= 3 * 10^4`
- `s` и `p` содержат только строчные английские буквы.

### Решения

#### 1. Полный перебор (Brute-force Checking)

**Идея:** Проверяем каждую подстроку длиной `len(p)` в `s`, сортируя её и сравнивая с отсортированной `p`.

**Интуиция:** Простой, но неэффективный подход из-за сортировки каждой подстроки.

```python
def findAnagrams(s, p):
    result = []
    sorted_p = sorted(p)
    
    for i in range(len(s) - len(p) + 1):
        substring = s[i:i+len(p)]
        if sorted(substring) == sorted_p:
            result.append(i)
    
    return result
```

**Временная сложность:** O((n - m) * m * log m)  
- n — длина `s`, m — длина `p`, сортировка подстроки занимает O(m * log m).

**Пространственная сложность:** O(m)  
- Для хранения отсортированной версии `p`.

#### 2. Сортировка и хэш-таблица (Sorting and HashMap)

**Идея:** Используем скользящее окно и частотный словарь для сравнения подстрок с `p`.

**Интуиция:** Частотный словарь позволяет избежать сортировки, сравнивая частоты символов.

```python
from collections import Counter

def findAnagrams(s, p):
    result = []
    p_count = Counter(p)
    s_count = Counter(s[:len(p) - 1])

    for i in range(len(p) - 1, len(s)):
        s_count[s[i]] += 1
        if s_count == p_count:
            result.append(i - len(p) + 1)
        s_count[s[i - len(p) + 1]] -= 1
        if s_count[s[i - len(p) + 1]] == 0:
            del s_count[s[i - len(p) + 1]]

    return result
```

**Временная сложность:** O(n)  
- Один проход по `s`, операции со словарем — O(1) в среднем.

**Пространственная сложность:** O(1)  
- Размер словаря ограничен количеством строчных букв (26).

#### 3. Эффективное скользящее окно с хэш-таблицей (Efficient Sliding Window with HashMap)

**Идея:** Оптимизируем скользящее окно, обновляя частотный словарь за O(1) на каждой итерации.

**Интуиция:** Постепенное добавление и удаление символов минимизирует вычисления.

```python
from collections import Counter

def findAnagrams(s, p):
    result = []
    p_count = Counter(p)
    s_count = Counter()

    for i in range(len(s)):
        s_count[s[i]] += 1
        
        if i >= len(p):
            if s_count[s[i - len(p)]] == 1:
                del s_count[s[i - len(p)]]
            else:
                s_count[s[i - len(p)]] -= 1
        
        if p_count == s_count:
            result.append(i - len(p) + 1)
        
    return result
```

**Временная сложность:** O(n)  
- Один проход по `s`.

**Пространственная сложность:** O(1)  
- Фиксированный размер словаря.

### Рекомендации для собеседования
- **Оптимальное решение:** Эффективное скользящее окно за счет O(n) времени и ясности.
- **Объяснение:** Покажите, как скользящее окно и словарь оптимизируют проверку анаграмм.
- **Крайние случаи:** Обсудите случаи, когда `p` длиннее `s` или `s` пустая.
- **Практика:** Попрактикуйтесь в работе с Counter и скользящим окном.

---

## 3. [567. Перестановка в строке](https://leetcode.com/problems/permutation-in-string/)

### Условие задачи

Даны две строки `s1` и `s2`, определите, содержит ли `s2` подстроку, которая является перестановкой `s1` (т.е. содержит те же символы с той же частотой).

**Примеры:**

```
Пример 1:
Вход: s1 = "ab", s2 = "eidbaooo"
Выход: true
Объяснение: Подстрока "ba" (индексы 3-4) является перестановкой "ab".

Пример 2:
Вход: s1 = "ab", s2 = "eidboaoo"
Выход: false
```

**Ограничения:**
- `1 <= s1.length, s2.length <= 10^4`
- `s1` и `s2` содержат только строчные английские буквы.

### Решения

#### 1. Генерация всех перестановок (Generate All Permutations)

**Идея:** Генерируем все перестановки `s1` и проверяем, является ли какая-либо из них подстрокой `s2`.

**Интуиция:** Простой, но крайне неэффективный подход из-за факториальной сложности.

```python
from itertools import permutations

def checkInclusion(s1: str, s2: str) -> bool:
    perm = permutations(s1)
    for p in perm:
        if ''.join(p) in s2:
            return True
    return False
```

**Временная сложность:** O(n! * m)  
- n — длина `s1`, m — длина `s2`, генерация перестановок занимает O(n!).

**Пространственная сложность:** O(n!)  
- Для хранения перестановок.

#### 2. Скользящее окно с сравнением частот (Sliding Window with Character Count Comparison)

**Идея:** Используем скользящее окно длиной `len(s1)` и сравниваем частоты символов с `s1`.

**Интуиция:** Частотные массивы позволяют быстро проверить, является ли подстрока перестановкой.

```python
def checkInclusion(s1: str, s2: str) -> bool:
    if len(s1) > len(s2):
        return False

    s1_count = [0] * 26
    s2_count = [0] * 26

    for i in range(len(s1)):
        s1_count[ord(s1[i]) - ord('a')] += 1
        s2_count[ord(s2[i]) - ord('a')] += 1
    
    def matches(s1_count, s2_count):
        return s1_count == s2_count

    for i in range(len(s1), len(s2)):
        if matches(s1_count, s2_count):
            return True
        s2_count[ord(s2[i]) - ord('a')] += 1
        s2_count[ord(s2[i - len(s1)]) - ord('a')] -= 1

    return matches(s1_count, s2_count)
```

**Временная сложность:** O(l + m)  
- l — длина `s1`, m — длина `s2`, один проход по `s2`.

**Пространственная сложность:** O(1)  
- Фиксированный размер массивов (26).

### Рекомендации для собеседования
- **Оптимальное решение:** Скользящее окно с частотами за счет O(n) времени.
- **Объяснение:** Объясните, как частотные массивы заменяют перестановки.
- **Крайние случаи:** Обсудите случаи, когда `s1` длиннее `s2` или `s2` пустая.
- **Практика:** Попрактикуйтесь в реализации скользящего окна с массивами.

---

## 4. [2461. Максимальная сумма уникальных подмассивов длиной K](https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/)

### Условие задачи

Дан массив целых чисел `nums` и целое число `k`, найдите максимальную сумму подмассива длиной `k`, в котором все элементы уникальны.

**Примеры:**

```
Пример 1:
Вход: nums = [1,5,4,2,9,9,9], k = 3
Выход: 15
Объяснение: Подмассив [5,4,2] имеет сумму 15, все элементы уникальны.

Пример 2:
Вход: nums = [4,4,4], k = 3
Выход: 0
Объяснение: Нет подмассива с уникальными элементами.
```

**Ограничения:**
- `1 <= k <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^9`

### Решения

#### 1. Полный перебор (Brute Force Approach)

**Идея:** Проверяем каждый подмассив длиной `k`, подсчитываем сумму, если элементы уникальны.

**Интуиция:** Простой подход, но неэффективный из-за создания множества для каждого подмассива.

```python
def maxSumOfDistinctSubarray(nums, k):
    n = len(nums)
    max_sum = 0
    
    for i in range(n - k + 1):
        current_window = nums[i:i+k]
        if len(set(current_window)) == k:
            current_sum = sum(current_window)
            max_sum = max(max_sum, current_sum)
    
    return max_sum
```

**Временная сложность:** O(n * k)  
- Для каждого подмассива создаем множество и вычисляем сумму.

**Пространственная сложность:** O(k)  
- Для хранения множества.

#### 2. Скользящее окно с множеством (Sliding Window + Set Approach)

**Идея:** Используем скользящее окно фиксированного размера `k` и множество для отслеживания уникальности.

**Интуиция:** При добавлении нового элемента удаляем дубликаты, поддерживая окно размера `k`.

```python
def maxSumOfDistinctSubarray(nums, k):
    n = len(nums)
    max_sum = 0
    current_sum = 0
    current_set = set()
    left = 0

    for right in range(n):
        while nums[right] in current_set:
            current_set.remove(nums[left])
            current_sum -= nums[left]
            left += 1

        current_set.add(nums[right])
        current_sum += nums[right]

        if right - left + 1 == k:
            max_sum = max(max_sum, current_sum)
            current_set.remove(nums[left])
            current_sum -= nums[left]
            left += 1
    
    return max_sum
```

**Временная сложность:** O(n)  
- Каждый элемент добавляется и удаляется не более одного раза.

**Пространственная сложность:** O(k)  
- Для хранения множества.