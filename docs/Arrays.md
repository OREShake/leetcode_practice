## 1. [283. Перемещение нулей](https://leetcode.com/problems/move-zeroes/)

### Условие задачи

Дан массив целых чисел `nums`, переместите все нули в конец массива, сохраняя относительный порядок ненулевых элементов. Изменения должны выполняться на месте.

**Примеры:**

```
Пример 1:
Вход: nums = [0,1,0,3,12]
Выход: [1,3,12,0,0]

Пример 2:
Вход: nums = [0]
Выход: [0]
```

**Ограничения:**
- `1 <= nums.length <= 10^4`
- `-2^31 <= nums[i] <= 2^31 - 1`

### Решения

#### 1. Наивный подход с дополнительным массивом

**Идея:** Собираем ненулевые элементы в новый массив, затем добавляем нули и копируем обратно.

**Интуиция:** Простой способ — отделить ненулевые элементы, а затем заполнить остаток нулями.

```python
def moveZeroes(nums):
    result = []
    
    for num in nums:
        if num != 0:
            result.append(num)
    
    zero_count = len(nums) - len(result)
    result.extend([0] * zero_count)
    
    for i in range(len(nums)):
        nums[i] = result[i]
```

**Временная сложность:** O(n)  
- Два прохода: сбор ненулевых элементов и копирование.

**Пространственная сложность:** O(n)  
- Используется дополнительный массив.

#### 2. Оптимальный подход с двумя указателями

**Идея:** Используем указатель для отслеживания позиции следующего ненулевого элемента и перемещаем ненулевые элементы в начало.

**Интуиция:** Перемещение ненулевых элементов вперед, а затем заполнение конца нулями выполняется на месте.

```python
def moveZeroes(nums):
    last_non_zero_found_at = 0
    
    for i in range(len(nums)):
        if nums[i] != 0:
            nums[last_non_zero_found_at], nums[i] = nums[i], nums[last_non_zero_found_at]
            last_non_zero_found_at += 1
```

**Временная сложность:** O(n)  
- Один проход с константными операциями обмена.

**Пространственная сложность:** O(1)  
- Изменения на месте, без дополнительной памяти.

---
## 2. [169. Элемент большинства](https://leetcode.com/problems/majority-element/)

### Условие задачи

Дан массив целых чисел `nums` размером `n`, найдите элемент, который встречается более чем `⌊n/2⌋` раз. Вы можете предположить, что такой элемент всегда существует в массиве.

**Примеры:**

```
Пример 1:
Вход: nums = [3,2,3]
Выход: 3

Пример 2:
Вход: nums = [2,2,1,1,1,2,2]
Выход: 2
```

**Ограничения:**
- `n == nums.length`
- `1 <= n <= 5 * 10^4`
- `-10^9 <= nums[i] <= 10^9`

### Решения

#### 1. Полный перебор (Brute Force)

**Идея:** Подсчитываем количество каждого элемента и возвращаем тот, который встречается более `⌊n/2⌋` раз.

**Интуиция:** Поскольку элемент большинства встречается чаще половины, проверка каждого элемента гарантирует результат.

```python
def majorityElement(nums):
    majority_count = len(nums) // 2
    for num in nums:
        count = sum(1 for elem in nums if elem == num)
        if count > majority_count:
            return num
```

**Временная сложность:** O(n²)  
- Внешний цикл O(n), внутренний подсчет O(n).

**Пространственная сложность:** O(1)  
- Используются только переменные.

#### 2. Подсчет с хэш-таблицей (Hash Map Counting)

**Идея:** Используем словарь для подсчета количества появлений элементов, возвращая элемент, превышающий `⌊n/2⌋`.

**Интуиция:** Хэш-таблица позволяет быстро подсчитывать элементы за один проход.

```python
def majorityElement(nums):
    counts = {}
    majority_count = len(nums) // 2
    for num in nums:
        if num in counts:
            counts[num] += 1
        else:
            counts[num] = 1
        if counts[num] > majority_count:
            return num
```

**Временная сложность:** O(n)  
- Один проход с операциями хэш-таблицы O(1).

**Пространственная сложность:** O(n)  
- Хэш-таблица может содержать до n элементов.

#### 3. Сортировка (Sorting)

**Идея:** После сортировки элемент большинства всегда будет в позиции `⌊n/2⌋`.

**Интуиция:** Элемент большинства встречается более чем в половине случаев, поэтому он окажется в середине.

```python
def majorityElement(nums):
    nums.sort()
    return nums[len(nums) // 2]
```

**Временная сложность:** O(n log n)  
- Сложность определяется сортировкой.

**Пространственная сложность:** O(1) или O(n)  
- Зависит от реализации сортировки (встроенная в Python может использовать O(n)).

#### 4. Алгоритм голосования Бойера-Мура (Boyer-Moore Voting Algorithm)

**Идея:** Поддерживаем кандидата и счетчик, увеличивая счетчик для того же элемента и уменьшая для других.

**Интуиция:** Элемент большинства доминирует, поэтому в процессе "голосования" он останется последним кандидатом.

```python
def majorityElement(nums):
    count = 0
    candidate = None

    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)

    return candidate
```

**Временная сложность:** O(n)  
- Один проход по массиву.

**Пространственная сложность:** O(1)  
- Используются только переменные.

---
## 3. [26. Удаление дубликатов из отсортированного массива](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)

### Условие задачи

Дан отсортированный по неубыванию массив целых чисел `nums`, удалите дубликаты на месте так, чтобы каждый уникальный элемент появлялся ровно один раз. Относительный порядок элементов должен сохраняться. Верните количество уникальных элементов `k`.

**Примеры:**

```
Пример 1:
Вход: nums = [1,1,2]
Выход: 2, nums = [1,2,_]
Объяснение: Функция возвращает k = 2, первые два элемента массива — [1,2].

Пример 2:
Вход: nums = [0,0,1,1,1,2,2,3,3,4]
Выход: 5, nums = [0,1,2,3,4,_,_,_,_,_]
Объяснение: Функция возвращает k = 5, первые пять элементов — [0,1,2,3,4].
```

**Ограничения:**
- `1 <= nums.length <= 3 * 10^4`
- `-100 <= nums[i] <= 100`
- Массив `nums` отсортирован по неубыванию.

### Решения

#### 1. Использование дополнительного массива

**Идея:** Создаем новый массив для хранения уникальных элементов, а затем копируем их обратно в исходный массив.

**Интуиция:** Поскольку массив отсортирован, мы можем добавлять элемент в новый массив только тогда, когда он отличается от последнего добавленного.

```python
def removeDuplicates(nums):
    if not nums:
        return 0
    
    unique_nums = [nums[0]]
    
    for num in nums[1:]:
        if num != unique_nums[-1]:
            unique_nums.append(num)
    
    for i in range(len(unique_nums)):
        nums[i] = unique_nums[i]
    
    return len(unique_nums)
```

**Временная сложность:** O(n)  
- Один проход для создания массива уникальных элементов и один для копирования.

**Пространственная сложность:** O(n)  
- Используется дополнительный массив для хранения уникальных элементов.

#### 2. Два указателя (Two Pointers)

**Идея:** Используем два указателя: один для прохода по массиву (`i`), другой для указания позиции для следующего уникального элемента (`j`).

**Интуиция:** Если текущий элемент отличается от последнего уникального, записываем его на позицию `j` и увеличиваем `j`.

```python
def removeDuplicates(nums):
    if not nums:
        return 0
    
    j = 0
    
    for i in range(1, len(nums)):
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
            
    return j + 1
```

**Временная сложность:** O(n)  
- Один проход по массиву.

**Пространственная сложность:** O(1)  
- Изменения производятся на месте, без дополнительной памяти.

---
## 4. [121. Лучшее время для покупки и продажи акций](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

### Условие задачи

Дан массив `prices`, где `prices[i]` — это цена акции в i-й день. Вы хотите максимизировать прибыль, купив акцию в один день и продав её в другой день в будущем. Верните максимальную возможную прибыль. Если прибыль получить невозможно, верните 0.

**Примеры:**

```
Пример 1:
Вход: prices = [7,1,5,3,6,4]
Выход: 5
Объяснение: Купите в день 2 (цена = 1) и продайте в день 5 (цена = 6), прибыль = 6-1 = 5.

Пример 2:
Вход: prices = [7,6,4,3,1]
Выход: 0
Объяснение: Цены только падают, прибыль невозможна.
```

**Ограничения:**
- `1 <= prices.length <= 10^5`
- `0 <= prices[i] <= 10^4`

### Решения

#### 1. Полный перебор (Brute Force)

**Идея:** Проверяем все возможные пары дней для покупки и продажи, вычисляя прибыль для каждой пары и отслеживая максимальную.

**Интуиция:** Перебираем каждый день как день покупки и каждый последующий день как день продажи, чтобы найти максимальную разницу цен.

```python
def maxProfit(prices):
    max_profit = 0
    n = len(prices)
    
    for i in range(n):
        for j in range(i + 1, n):
            profit = prices[j] - prices[i]
            if profit > max_profit:
                max_profit = profit
                
    return max_profit
```

**Временная сложность:** O(n²)  
- Два вложенных цикла для проверки всех пар дней.

**Пространственная сложность:** O(1)  
- Используется только фиксированное количество переменных.

#### 2. Однопроходный подход (One Pass)

**Идея:** Отслеживаем минимальную цену, встреченную до текущего дня, и вычисляем потенциальную прибыль для каждого дня, сравнивая с этой минимальной ценой.

**Интуиция:** Максимальная прибыль достигается, если мы покупаем по минимальной цене и продаем по текущей цене, если разница положительна.

```python
def maxProfit(prices):
    max_profit = 0
    min_price = float('inf')
    
    for price in prices:
        if price < min_price:
            min_price = price
        profit = price - min_price
        if profit > max_profit:
            max_profit = profit
            
    return max_profit
```

**Временная сложность:** O(n)  
- Один проход по массиву цен.

**Пространственная сложность:** O(1)  
- Используются только переменные для минимальной цены и максимальной прибыли.

---
## 5. [189. Поворот массива](https://leetcode.com/problems/rotate-array/)

### Условие задачи

Дан массив `nums`, поверните его вправо на `k` шагов. Изменения должны выполняться на месте.

**Примеры:**

```
Пример 1:
Вход: nums = [1,2,3,4,5,6,7], k = 3
Выход: [5,6,7,1,2,3,4]

Пример 2:
Вход: nums = [-1,-100,3,99], k = 2
Выход: [3,99,-1,-100]
```

**Ограничения:**
- `1 <= nums.length <= 10^5`
- `-2^31 <= nums[i] <= 2^31 - 1`
- `0 <= k <= 10^5`

### Решения

#### 1. Полный перебор (Brute Force)

**Идея:** Поворачиваем массив по одному шагу `k` раз.

**Интуиция:** Каждый шаг перемещает последний элемент в начало, сдвигая остальные вправо.

```python
def rotate(nums, k):
    n = len(nums)
    k %= n
    for _ in range(k):
        last = nums[-1]
        for i in range(n-1, 0, -1):
            nums[i] = nums[i-1]
        nums[0] = last
```

**Временная сложность:** O(n × k)  
- Каждый поворот занимает O(n), повторяется k раз.

**Пространственная сложность:** O(1)  
- Изменения на месте.

#### 2. Использование дополнительного массива

**Идея:** Создаем новый массив, размещая элементы в позициях `(i + k) % n`, затем копируем обратно.

**Интуиция:** Позиция каждого элемента после поворота определяется формулой `(i + k) % n`.

```python
def rotate(nums, k):
    n = len(nums)
    k %= n
    rotated = [0] * n
    for i in range(n):
        rotated[(i + k) % n] = nums[i]
    nums[:] = rotated
```

**Временная сложность:** O(n)  
- Один проход для размещения элементов и копирования.

**Пространственная сложность:** O(n)  
- Используется дополнительный массив.

#### 3. Разворот массива (Reverse Array)

**Идея:** Разворачиваем весь массив, затем первые `k` элементов и оставшиеся `n-k` элементов.

**Интуиция:** Развороты позволяют эффективно переместить элементы на нужные позиции.

```python
def rotate(nums, k):
    n = len(nums)
    k %= n
    
    def reverse(start, end):
        while start < end:
            nums[start], nums[end] = nums[end], nums[start]
            start += 1
            end -= 1

    reverse(0, n - 1)
    reverse(0, k - 1)
    reverse(k, n - 1)
```

**Временная сложность:** O(n)  
- Три разворота, каждый O(n).

**Пространственная сложность:** O(1)  
- Изменения на месте.

---
## 6. [238. Произведение массива, кроме самого себя](https://leetcode.com/problems/product-of-array-except-self/)

### Условие задачи

Дан массив целых чисел `nums`, верните массив `output`, где `output[i]` равен произведению всех элементов `nums`, кроме `nums[i]`. Решение не должно использовать деление и должно иметь сложность O(n).

**Примеры:**

```
Пример 1:
Вход: nums = [1,2,3,4]
Выход: [24,12,8,6]

Пример 2:
Вход: nums = [-1,1,0,-3,3]
Выход: [0,0,9,0,0]
```

**Ограничения:**
- `2 <= nums.length <= 10^5`
- `-30 <= nums[i] <= 30`
- Произведение любых префикса или суффикса гарантированно помещается в 32-битное целое число.

### Решения

#### 1. Полный перебор (Brute Force)

**Идея:** Для каждого элемента вычисляем произведение всех остальных.

**Интуиция:** Перебираем массив для каждого элемента, исключая его самого.

```python
def productExceptSelf(nums):
    length = len(nums)
    output = [1] * length
    for i in range(length):
        prod = 1
        for j in range(length):
            if i != j:
                prod *= nums[j]
        output[i] = prod
    return output
```

**Временная сложность:** O(n²)  
- Для каждого элемента перебираем массив.

**Пространственная сложность:** O(n)  
- Используется только выходной массив.

#### 2. Префиксные и суффиксные произведения

**Идея:** Создаем массивы префиксных и суффиксных произведений, затем перемножаем их.

**Интуиция:** Произведение всех элементов, кроме текущего, — это произведение элементов до и после него.

```python
def productExceptSelf(nums):
    length = len(nums)
    prefix = [1] * length
    suffix = [1] * length
    output = [1] * length

    for i in range(1, length):
        prefix[i] = prefix[i - 1] * nums[i - 1]

    for i in range(length - 2, -1, -1):
        suffix[i] = suffix[i + 1] * nums[i + 1]

    for i in range(length):
        output[i] = prefix[i] * suffix[i]

    return output
```

**Временная сложность:** O(n)  
- Три прохода по массиву.

**Пространственная сложность:** O(n)  
- Используются массивы для префиксов и суффиксов.

#### 3. Оптимизированное префиксное и суффиксное произведение

**Идея:** Используем выходной массив для хранения префиксных произведений, а суффиксное произведение вычисляем на лету.

**Интуиция:** Устраняем необходимость в дополнительных массивах, сохраняя O(1) память.

```python
def productExceptSelf(nums):
    length = len(nums)
    output = [1] * length

    for i in range(1, length):
        output[i] = output[i - 1] * nums[i - 1]

    suffix_product = 1
    for i in range(length - 1, -1, -1):
        output[i] *= suffix_product
        suffix_product *= nums[i]

    return output
```

**Временная сложность:** O(n)  
- Два прохода по массиву.

**Пространственная сложность:** O(1)  
- Кроме выходного массива, память не используется.

---
## 7. [122. Лучшее время для покупки и продажи акций II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)

### Условие задачи

Дан массив `prices`, где `prices[i]` — цена акции в i-й день. Вы можете совершать столько сделок, сколько хотите (покупка и продажа одной акции), но нельзя держать более одной акции одновременно. Найдите максимальную возможную прибыль.

**Примеры:**

```
Пример 1:
Вход: prices = [7,1,5,3,6,4]
Выход: 7
Объяснение: Покупка в день 2 (цена = 1), продажа в день 3 (цена = 5), прибыль = 4. Покупка в день 4 (цена = 3), продажа в день 5 (цена = 6), прибыль = 3. Итого 7.

Пример 2:
Вход: prices = [1,2,3,4,5]
Выход: 4
Объяснение: Покупка в день 1 (цена = 1), продажа в день 5 (цена = 5), прибыль = 4.
```

**Ограничения:**
- `1 <= prices.length <= 3 * 10^5`
- `0 <= prices[i] <= 10^5`

### Решения

#### 1. Простой однопроходный подход (Simple One Pass)

**Идея:** Суммируем все положительные разницы между последовательными днями, где цена возрастает.

**Интуиция:** Каждая восходящая разница — это возможность для прибыли, которую мы можем захватить.

```python
def maxProfit(prices):
    total_profit = 0
    
    for i in range(1, len(prices)):
        if prices[i] > prices[i - 1]:
            total_profit += prices[i] - prices[i - 1]
    
    return total_profit
```

**Временная сложность:** O(n)  
- Один проход по массиву.

**Пространственная сложность:** O(1)  
- Используется только переменная для прибыли.

#### 2. Оптимальный жадный подход (Optimal Greedy)

**Идея:** То же, что и простой подход, суммируем все положительные разницы цен.

**Интуиция:** Жадный подход максимизирует прибыль, захватывая все восходящие изменения цен.

```python
def maxProfit(prices):
    total_profit = 0
    
    for i in range(1, len(prices)):
        if prices[i] > prices[i - 1]:
            total_profit += prices[i] - prices[i - 1]
    
    return total_profit
```

**Временная сложность:** O(n)  
- Один проход по массиву.

**Пространственная сложность:** O(1)  
- Используется только переменная для прибыли.

---
## 8. [2348. Количество подмассивов, заполненных нулями](https://leetcode.com/problems/number-of-zero-filled-subarrays/)

### Условие задачи

Дан массив целых чисел `nums`, верните количество подмассивов, состоящих только из нулей.

**Примеры:**

```
Пример 1:
Вход: nums = [1,3,0,0,2,0,0,4]
Выход: 6
Объяснение: Подмассивы [0], [0], [0,0], [0], [0], [0,0] состоят из нулей.

Пример 2:
Вход: nums = [0,0,0,2,0,0]
Выход: 9
Объяснение: Подмассивы: три [0], два [0,0], один [0,0,0], три [0].
```

**Ограничения:**
- `1 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`

### Решения

#### 1. Полный перебор (Brute Force)

**Идея:** Проверяем все возможные подмассивы, подсчитывая те, которые состоят только из нулей.

**Интуиция:** Для каждого начального индекса проверяем подмассивы, пока не встретим ненулевой элемент.

```python
def zeroFilledSubarray(nums):
    count = 0
    
    for i in range(len(nums)):
        for j in range(i, len(nums)):
            if nums[j] == 0:
                count += 1
            else:
                break
    
    return count
```

**Временная сложность:** O(n²)  
- Перебираем все возможные подмассивы.

**Пространственная сложность:** O(1)  
- Используется только счетчик.

#### 2. Оптимизированное скользящее окно

**Идея:** Подсчитываем подмассивы нулей, отслеживая длину текущей последовательности нулей.

**Интуиция:** Каждая последовательность из `k` нулей дает `k + (k-1) + ... + 1` подмассивов.

```python
def zeroFilledSubarray(nums):
    count = 0
    zero_seq_length = 0
    
    for num in nums:
        if num == 0:
            zero_seq_length += 1
            count += zero_seq_length
        else:
            zero_seq_length = 0
    
    return count
```

**Временная сложность:** O(n)  
- Один проход по массиву.

**Пространственная сложность:** O(1)  
- Используются только счетчики.

---
## 9. [334. Возрастающая тройка](https://leetcode.com/problems/increasing-triplet-subsequence/)

### Условие задачи

Дан массив целых чисел `nums`, определите, существует ли возрастающая подпоследовательность длиной 3 (т.е. существуют ли индексы `i < j < k` такие, что `nums[i] < nums[j] < nums[k]`). Верните `true`, если такая подпоследовательность существует, иначе `false`.

**Примеры:**

```
Пример 1:
Вход: nums = [1,2,3,4,5]
Выход: true
Объяснение: Тройка [1,2,3] является возрастающей.

Пример 2:
Вход: nums = [5,4,3,2,1]
Выход: false
Объяснение: Нет возрастающей тройки.
```

**Ограничения:**
- `1 <= nums.length <= 5 * 10^5`
- `-2^31 <= nums[i] <= 2^31 - 1`

### Решения

#### 1. Полный перебор (Brute Force)

**Идея:** Проверяем все возможные тройки на возрастающий порядок.

**Интуиция:** Перебираем все комбинации индексов `i`, `j`, `k`, где `i < j < k`, и проверяем условие.

```python
def increasingTriplet(nums):
    n = len(nums)
    for i in range(n):
        for j in range(i + 1, n):
            for k in range(j + 1, n):
                if nums[i] < nums[j] < nums[k]:
                    return True
    return False
```

**Временная сложность:** O(n³)  
- Три вложенных цикла для проверки всех троек.

**Пространственная сложность:** O(1)  
- Используются только переменные цикла.

#### 2. Оптимизированный линейный проход с вспомогательными переменными

**Идея:** Отслеживаем наименьший и второй по величине элементы, чтобы найти тройку.

**Интуиция:** Если найдется число больше второго по величине, то тройка существует.

```python
def increasingTriplet(nums):
    first = second = float('inf')
    for num in nums:
        if num <= first:
            first = num
        elif num <= second:
            second = num
        else:
            return True
    return False
```

**Временная сложность:** O(n)  
- Один проход по массиву.

**Пространственная сложность:** O(1)  
- Используются только две переменные.